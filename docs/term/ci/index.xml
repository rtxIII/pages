<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CI on </title>
    <link>https://rtx3.com/term/ci/</link>
    <description>Recent content in CI on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 30 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://rtx3.com/term/ci/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Devops-持续交付CD</title>
      <link>https://rtx3.com/post/d/devops-cd/</link>
      <pubDate>Tue, 30 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://rtx3.com/post/d/devops-cd/</guid>
      <description>&lt;h1 id=&#34;持续交付&#34;&gt;持续交付&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ocf.rtx3.com/api/raw?path=/3/assets/devops/cd.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;渐进式交付&#34;&gt;渐进式交付&lt;/h2&gt;&#xA;&lt;p&gt;渐进式交付是高级部署模式（如金丝雀，功能标记和 A/B 测试）的总称。通过给予应用程序开发人员和 SRE 团队对爆炸半径的细粒度控制，渐进交付技术被用来降低在生产中引入新软件版本的风险。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用金丝雀的好处是能够在生产环境中使用发现问题的安全回滚策略对新版本进行容量测试。通过缓慢增加负载，您可以监视和捕获有关新版本如何影响生产环境的指标&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;gitops-下的-cicd-流程&#34;&gt;GitOps 下的 CI/CD 流程&lt;/h1&gt;&#xA;&lt;p&gt;CI/CD 是架构中非常重要的一个组件，在云原生时代，依托于容器化持续集成，改变了以往应用通过 Jar、war 包形式的部署方式，转而制作成镜像，通过集成 GitLab CI、镜像仓库、Kubernetes 、Argo CD 等各类效率、流程系统，对纳管集群进行镜像发布、应用验证、升级，进而实现了自动化和监控贯穿于应用迭代的整个生命周期。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是-cicd&#34;&gt;什么是 CI/CD&lt;/h2&gt;&#xA;&lt;p&gt;CI（Continuous Intergration，持续集成），强调开发人员不断进行代码提交、单元测试、性能测试、代码扫描等操作，根据测试结果，发现问题及时回滚，并进行反馈。&lt;/p&gt;&#xA;&lt;p&gt;持续部署 （Continuous Deployment，CD）或者说持续交付（Continuous Delivery，CD），是指在构建和测试完成通过后，通过一系列系统化手段让最新的功能能够尽快地更新到生产环境，并通过运营反馈需求，促进产品进一步迭代。持续部署需要保障整个过程的平滑和安全，通常借助蓝绿发布、金丝雀发布确保过程中的平滑、安全以及降低部署过程出错的概率。&lt;/p&gt;&#xA;&lt;p&gt;总结来说，持续集成、持续部署与持续交付，是一种通过在应用开发阶段引入自动化，实现频繁交付应用的方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;gitops-下的-cicd-流程-1&#34;&gt;GitOps 下的 CI/CD 流程&lt;/h2&gt;&#xA;&lt;p&gt;鉴于 GitOps 的设计哲学，我们看一下 GitOps 下的 CI/CD 流程，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;![image](&lt;a href=&#34;https://ocf.rtx3.com/api/raw?path=/3/assets/devops/gitops-workflow.webp&#34;&gt;https://ocf.rtx3.com/api/raw?path=/3/assets/devops/gitops-workflow.webp&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首先，团队成员都可以 fork 仓库对配置进行更改，然后提交 Pull Request。&lt;/li&gt;&#xA;&lt;li&gt;接下来运行 CI 流水线，进行校验配置文件、执行自动化测试、构建 OCI 镜像、推送到镜像仓库等。&lt;/li&gt;&#xA;&lt;li&gt;CI 流水线执行完成后，拥有合并代码权限的人会将 Pull Request 合并到主分支。&lt;/li&gt;&#xA;&lt;li&gt;最后运行 CD 流水线，结合 CD 工具（例如 Argo CD）将变更自动应用到目标集群中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;整个过程中完全自动化且操作透明，通过多人协作和自动化测试来保证了基础设施声明的健壮性。另外由于基础设置配置都存储在 Git 仓库中，当应用出现故障时，也可快速地进行版本回退。&lt;/p&gt;&#xA;&lt;h2 id=&#34;cicd-中的工具链&#34;&gt;CI/CD 中的工具链&lt;/h2&gt;&#xA;&lt;p&gt;在 CI/CD 工程实施中，Jenkins 和 Gitlab 已成为流程中的核心工具，其中 Jenkins 。现如今的 CI/CD 中，集合容器技术、镜像仓库、容器编排系统等各类工具链，已成为企业、各类组织效率提升必不可少的基础支撑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Devops-持续交付CI</title>
      <link>https://rtx3.com/post/d/devops-ci/</link>
      <pubDate>Tue, 30 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://rtx3.com/post/d/devops-ci/</guid>
      <description>&lt;h1 id=&#34;持续集成&#34;&gt;持续集成&lt;/h1&gt;&#xA;&lt;p&gt;持续集成是系统持续提供可交付版本软件并且保证软件质量的一种开发方法。&lt;/p&gt;&#xA;&lt;p&gt;它主张开发人员尽可能早、快地将各自开发的代码集成起来，每次集成都通过自动化的构建（包括静态代码扫描、编译、自动化测试、发布等）来进行质量验证，从而尽可能早地发现集成错误，避免项目延期以及不可预测的质量风险等。&lt;/p&gt;&#xA;&lt;p&gt;持续集成系统的价值在于完全自动化构建和自动化测试，在微服务持续集成中，包含的关键要素为源代码库、持续集成机系统、自动化测试系统。&lt;/p&gt;&#xA;&lt;p&gt;一个典型的持续集成过程为：开发团队基于源代码库（如 Git）建立持续集成系统，当团队成员对源代码就行更新并提交到源码库之后，持续集成系统先从版本控制服务器下载更新后的代码，调用自动化编译脚本进行编译，并运行开发人员预先编写的自动化测试脚本，最后将测试结果生成报告反馈给开发团队，开发团队根据反馈结果进行下一轮的代码迭代更新，并触发新一轮的持续集成过程。&lt;/p&gt;&#xA;&lt;p&gt;GitLab CI 是为 Gitlab 提供持续集成的一整套系统，&lt;/p&gt;&#xA;&lt;h2 id=&#34;流水线pipeline&#34;&gt;流水线(Pipeline)&lt;/h2&gt;&#xA;&lt;p&gt;流水线是一个分成不同阶段（Stage）的作业（Job）的集合。一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。任何提交或者 Merge Request 的合并都可以触发 Pipeline。&lt;/p&gt;&#xA;&lt;h2 id=&#34;stages&#34;&gt;Stages&lt;/h2&gt;&#xA;&lt;p&gt;Stages 表示构建阶段，说白了就是上面提到的流程。 我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始&lt;/li&gt;&#xA;&lt;li&gt;只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功&lt;/li&gt;&#xA;&lt;li&gt;如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;jobs&#34;&gt;Jobs&lt;/h2&gt;&#xA;&lt;p&gt;Jobs 表示构建工作，表示某个 Stage 里面执行的工作。 我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;相同 Stage 中的 Jobs 会并行执行&lt;/li&gt;&#xA;&lt;li&gt;相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功&lt;/li&gt;&#xA;&lt;li&gt;如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;gitlab-runner&#34;&gt;GitLab Runner&lt;/h2&gt;&#xA;&lt;p&gt;理解了上面的基本概念之后，还有一个问题，由谁来执行这些构建任务呢？ 答案就是 GitLab Runner ！&lt;/p&gt;</description>
    </item>
    <item>
      <title>Devops-持续交付1IaC</title>
      <link>https://rtx3.com/post/d/devops-iac/</link>
      <pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://rtx3.com/post/d/devops-iac/</guid>
      <description>&lt;h1 id=&#34;基础设施即代码&#34;&gt;基础设施即代码&lt;/h1&gt;&#xA;&lt;p&gt;GitOps 一个最基础的工作是基础设施代码化。&lt;/p&gt;&#xA;&lt;p&gt;基础设施即代码（Infrastructure as Code, IaC），顾名思义，表示使用代码（而非手动流程）来定义基础设施，研发人员可以像对待应用软件一样对待基础设施，&#xA;包括对网络配置、虚拟机、负载平衡、连接拓扑等等都使用高级语言进行编码。&lt;/p&gt;&#xA;&lt;p&gt;对对应用开发所依靠的环境进行标准化后，DevOps 就能够启动、拆解和扩展基础设施，以响应不断波动的需求，这样的敏捷性能够造就更快、更简单的软件开发、测试和部署。&lt;/p&gt;&#xA;&lt;h2 id=&#34;iac-的优势&#34;&gt;IaC 的优势&lt;/h2&gt;&#xA;&lt;p&gt;置备基础架构历来是一个耗时且成本高昂的手动过程，随着云计算的发展，基础架构的管理已逐渐转移到了虚拟化、容器和云计算，在基础架构之上，有数以百计、千计的服务不断地更新迭代，另外基础架构本身也不断地使用、扩展和移除。在这种状态下，如果没有相应的 IaC 管理实践，大规模的基础架构维护也会变得越来越困难。&lt;/p&gt;&#xA;&lt;p&gt;使用 IaC  可以提高一致性并减少错误和手动配置，它的优势特点如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以创建包含基础架构规范的声明式配置文件，从而便于编辑和分发配置。&lt;/li&gt;&#xA;&lt;li&gt;可以确保每次配置的环境都完全相同。&lt;/li&gt;&#xA;&lt;li&gt;可以进行版本控制，所有的变更都会被记录下来，方便溯源。&lt;/li&gt;&#xA;&lt;li&gt;可以将基础设施划分为若干个模块化组件，并通过自动化以不同的方式进行组合。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;广义上的 IaC 不仅仅只关于基础设施，还包含了网络、安全、配置等等，所以 IaC 又叫 X as Code。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ocf.rtx3.com/api/raw?path=/3/assets/devops/x-as-code.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;iac-工具选型&#34;&gt;IaC 工具选型&lt;/h2&gt;&#xA;&lt;p&gt;大部分的公有云已经提供了良好的 API 和相应的 IaC 生态，而对于使用混合云的企业，还是需要一些投入将底层基础设施 IaC 化。&lt;/p&gt;&#xA;&lt;p&gt;云上资源 IaC 化，比较典型的工具是 Terraform。Terraform 可以说是 IaC 概念最早期的奠基项目，生态最为完善，社区也非常活跃，背后也有非常成熟的商业上市公司 HashiCorp 进行支持。Terraform 抽象了 HCL 这门相对简单易学的 DSL 作为资源描述语言，实践中配合 Terragrunt 这个工具（底层基于 Terraform 进行封装）能更好地写出相对紧凑简洁的代码。&lt;/p&gt;&#xA;&lt;p&gt;另外一个  Crossplane 。基于 Kubernetes 并通过封装好的形形色色的 CRDs 来操作多云资源。&lt;/p&gt;&#xA;&lt;p&gt;除以上云资源 IaC 化外，还有应用配置的 IaC，现在大部分企业选择 Kubernetes 作为 PaaS 的基座，行于 Kubernetes 之上的所有资源天然就已经被代码化了，其形式就是资源声明式 YAML 配置，但这种方式，过于简单，局限性过大。 从组织的角度来看，需要有对 yaml 更抽象的部署封装，这就是 Kustomize 和 Helm 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Devops-持续交付Gitops</title>
      <link>https://rtx3.com/post/d/devops-gitops/</link>
      <pubDate>Sun, 28 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://rtx3.com/post/d/devops-gitops/</guid>
      <description>&lt;h1 id=&#34;什么是-gitops&#34;&gt;什么是 GitOps&lt;/h1&gt;&#xA;&lt;p&gt;GitOps = IaC + Git+ CI/CD，即基于 IaC 版本化 CI/CD，它的核心是使用 Git 仓库来管理基础设施和应用的配置，并且以 Git 仓库作为基础设置和应用的单一事实来源。GitoOps 重新定义了云原生场景下的 CI/CD 流程。 开发、运维团队以 Git 版本控制，作为中心不可变状态声明，结合 CI/CD 流程中代码审查、自动测试和交付部署，从而实现云原生场景下运维体系的最佳实践。&lt;/p&gt;&#xA;&lt;p&gt;GitOps 是 DevOps 文化的一种工程实践，它重新定义了云原生场景下的持续交付模型。GitOps 下的整个运维体系使用声明式描述，并使用 Git 类似的版本控制系统对基础设施、应用配置等进行跟踪管理，系统任何变更在 Git 版本的控制下更加便捷地进行跟踪。&lt;/p&gt;&#xA;&lt;p&gt;GitOps 以目标为导向，使用 Git 来维护系统的期望状态，结合 CI/CD 流程中的工具，如 Helm、ArgoCD 等，提高了生产力、安全性和合规性，以及升应用交付的效率和质量保证。&lt;/p&gt;&#xA;&lt;h2 id=&#34;gitops-的设计理念&#34;&gt;GitOps 的设计理念&lt;/h2&gt;&#xA;&lt;p&gt;GitOps 本质上 DevOps 文化中的工程实践，而非某项具体的技术或项目，结合当今流行的使用形式，可将 GitOps 系统简单地理解为以下几大特点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;代码化描述基础设施和应用的部署状态&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;对于应用的基础设置资源、应用配置和状态的维护，原则都是应是使用代码化的方式进行声明式描述。只有将各类手动配置的工作代码化，我们才能使用 Git 仓库的形式来管理基础设施和应用的部署。&lt;/p&gt;&#xA;&lt;p&gt;对大规模应用管理的运维效率和可维护性的关键基础是 IaC （Infrastructure as Code），基础设置无法进行 IaC，GitOps 也就无从谈起。&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用 Git 的语义来管理代码化后的配置代码&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;基础设施代码化后面临着管理问题，而 GitOps 顾名思义，采用 Git 语义来管理这部分代码，主要有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IaC 代码存储于 Git 仓库中&lt;/li&gt;&#xA;&lt;li&gt;基于分支模式来管理代码版本&lt;/li&gt;&#xA;&lt;li&gt;开发人员使用 Pull Request 来提交 IaC 变更&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;更高级的管理人员，对这部分变更进行 Code Review，合规之后进行 Merge 到主版本，进而应用到线上环境， 而当线上环境出现问题时，再基于 Git 历史进行回退。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Devops-持续交付容器镜像</title>
      <link>https://rtx3.com/post/d/devops-docker-build/</link>
      <pubDate>Sat, 27 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://rtx3.com/post/d/devops-docker-build/</guid>
      <description>&lt;h1 id=&#34;构建镜像&#34;&gt;构建镜像&lt;/h1&gt;&#xA;&lt;p&gt;我们先前面讲述过，容器镜像实际上就是利用 UnionFs 实现的一个特殊文件系统。那么容器镜像的构建就是基于底层 rootfs （基础镜像）定制上层配置、文件、依赖等信息。我们把每一层修改、操作命令都写入一个脚本，用这个脚本来构建、定制镜像，这个脚本就是 Dockerfile。&lt;/p&gt;&#xA;&lt;p&gt;有了 Dockerfile 之后, 就可以制定自己的镜像规则，在 Dockerfile 上添加或者修改指令, 就可生成镜像产物。&lt;/p&gt;&#xA;&lt;p&gt;docker 镜像构建步骤如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编写 Dockerfile 文件&lt;/li&gt;&#xA;&lt;li&gt;docker build 命令构建镜像&lt;/li&gt;&#xA;&lt;li&gt;docker run 按照镜像运行容器实例。如下图所示：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ocf.rtx3.com/api/raw?path=/3/assets/devops/dockerfile.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-dockerfile-常用指令&#34;&gt;1. Dockerfile 常用指令&lt;/h2&gt;&#xA;&lt;p&gt;通过 Dockerfile 构建镜像时，Docker 安装顺序读取 Dockerfile 内的指令，并解析出所有的指令。这些指令被分成多个层，每个层都对应着一个镜像层。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ocf.rtx3.com/api/raw?path=/3/assets/devops/docker-image.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;下表列举了常用的 Dockerfile 指令。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;指令&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;FROM&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;指定构建镜像的基础镜像&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;MAINTAINER&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;镜像的维护信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;RUN&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;构建镜像时运行的指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;COPY&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;复制文件或目录到镜像内（只能在构建镜像的主机上读取资源）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;ADD&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;支持从远程服务器读取资源，复制到镜像内，同时支持自动解压 tar, zip 等压缩文件&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;ENV&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;环境变量设置&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;USER&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;指定运行 RUN、CMD COPY 等指令的用户&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;EXPOSE&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;容器运行的端口&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;WORKDIR&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;指定运行 RUN、CMD、COPY 指令的工作目录&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;VOLUME&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;设置挂载卷&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;CMD&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;启动后运行的指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;2-镜像构建&#34;&gt;2. 镜像构建&lt;/h2&gt;&#xA;&lt;p&gt;熟悉常用的 Dockerfile 指令之后，我们可以开始尝试通过 Dockerfile 构建一个 Nginx 镜像。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
